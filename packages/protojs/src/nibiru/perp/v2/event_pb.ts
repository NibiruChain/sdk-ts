// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file nibiru/perp/v2/event.proto (package nibiru.perp.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf"
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf"
import { AMM, Market, Position } from "./state_pb.js"
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js"

/**
 * Emitted when a position changes.
 *
 * @generated from message nibiru.perp.v2.PositionChangedEvent
 */
export class PositionChangedEvent extends Message<PositionChangedEvent> {
  /**
   * @generated from field: nibiru.perp.v2.Position final_position = 1;
   */
  finalPosition?: Position

  /**
   * Position notional (in quote units) after the change. In general,
   * 'notional = baseAmount * priceQuotePerBase', where size is the baseAmount.
   *
   * @generated from field: string position_notional = 2;
   */
  positionNotional = ""

  /**
   * Transaction fee paid. A "taker" fee.
   *
   * @generated from field: cosmos.base.v1beta1.Coin transaction_fee = 3;
   */
  transactionFee?: Coin

  /**
   * realize profits and losses after the change
   *
   * @generated from field: string realized_pnl = 4;
   */
  realizedPnl = ""

  /**
   * Amount of bad debt cleared by the PerpEF during the change.
   * Bad debt is negative net margin past the liquidation point of a position.
   *
   * @generated from field: cosmos.base.v1beta1.Coin bad_debt = 5;
   */
  badDebt?: Coin

  /**
   * A funding payment made or received by the trader on the current position.
   * 'fundingPayment' is positive if 'owner' is the sender and negative if 'owner'
   * is the receiver of the payment. Its magnitude is abs(size * fundingRate).
   * Funding payments act to converge the mark price and index price
   * (average price on major exchanges).
   *
   * @generated from field: string funding_payment = 6;
   */
  fundingPayment = ""

  /**
   * The block number at which this position was changed.
   *
   * @generated from field: int64 block_height = 7;
   */
  blockHeight = protoInt64.zero

  /**
   * margin_to_user is the amount of collateral received by the trader during
   * the position change. A positve value indicates that the trader received
   * funds, while a negative value indicates that the trader spent funds.
   *
   * @generated from field: string margin_to_user = 8;
   */
  marginToUser = ""

  /**
   * change_reason describes the reason for why the position resulted in a
   * change. Change type can take the following values:
   *
   * - CHANGE_REASON_UNSPECIFIED: Unspecified change reason.
   * - CHANGE_REASON_ADD_MARGIN: Margin was added to the position.
   * - CHANGE_REASON_REMOVE_MARGIN: Margin was removed from the position.
   * - CHANGE_REASON_OPEN_POSITION: A new position was opened.
   * - CHANGE_REASON_CLOSE_POSITION: An existing position was closed.
   *
   * @generated from field: string change_reason = 9;
   */
  changeReason = ""

  constructor(data?: PartialMessage<PositionChangedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.PositionChangedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "final_position", kind: "message", T: Position },
    { no: 2, name: "position_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transaction_fee", kind: "message", T: Coin },
    { no: 4, name: "realized_pnl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "bad_debt", kind: "message", T: Coin },
    { no: 6, name: "funding_payment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "block_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "margin_to_user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "change_reason", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): PositionChangedEvent {
    return new PositionChangedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): PositionChangedEvent {
    return new PositionChangedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): PositionChangedEvent {
    return new PositionChangedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: PositionChangedEvent | PlainMessage<PositionChangedEvent> | undefined,
    b: PositionChangedEvent | PlainMessage<PositionChangedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(PositionChangedEvent, a, b)
  }
}

/**
 * Emitted when a position is liquidated.
 *
 * @generated from message nibiru.perp.v2.PositionLiquidatedEvent
 */
export class PositionLiquidatedEvent extends Message<PositionLiquidatedEvent> {
  /**
   * identifier of the corresponding virtual pool for the position
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * owner of the position.
   *
   * @generated from field: string trader_address = 2;
   */
  traderAddress = ""

  /**
   * margin * leverage * vPrice. 'notional' is the virtual size times  the
   * virtual price on 'perp.amm'.
   *
   * @generated from field: string exchanged_quote_amount = 3;
   */
  exchangedQuoteAmount = ""

  /**
   * virtual amount of base assets for the position, which would be margin *
   * leverage * priceBasePerQuote.
   *
   * @generated from field: string exchanged_position_size = 4;
   */
  exchangedPositionSize = ""

  /**
   * Address of the account that executed the tx.
   *
   * @generated from field: string liquidator_address = 5;
   */
  liquidatorAddress = ""

  /**
   * Commission (in margin units) received by 'liquidator'.
   *
   * @generated from field: cosmos.base.v1beta1.Coin fee_to_liquidator = 6;
   */
  feeToLiquidator?: Coin

  /**
   * Commission (in margin units) given to the ecosystem fund.
   *
   * @generated from field: cosmos.base.v1beta1.Coin fee_to_ecosystem_fund = 7;
   */
  feeToEcosystemFund?: Coin

  /**
   *  Bad debt (margin units) cleared by the PerpEF during the tx. Bad debt is
   *  negative net margin past the liquidation point of a position.
   *
   * @generated from field: cosmos.base.v1beta1.Coin bad_debt = 8;
   */
  badDebt?: Coin

  /**
   * Remaining margin in the position after liquidation
   *
   * @generated from field: cosmos.base.v1beta1.Coin margin = 9;
   */
  margin?: Coin

  /**
   * Remaining position notional in the position after liquidation
   *
   * @generated from field: string position_notional = 10;
   */
  positionNotional = ""

  /**
   * Remaining position size in the position after liquidation
   *
   * @generated from field: string position_size = 11;
   */
  positionSize = ""

  /**
   * Unrealized PnL in the position after liquidation
   *
   * @generated from field: string unrealizedPnl = 12;
   */
  unrealizedPnl = ""

  /**
   * Spot price of the vAMM after liquidation
   *
   * @generated from field: string mark_price = 13;
   */
  markPrice = ""

  /**
   * The block number at which this liquidation occured.
   *
   * @generated from field: int64 block_height = 14;
   */
  blockHeight = protoInt64.zero

  /**
   * The unix timestamp in milliseconds at which this liquidation occured.
   *
   * @generated from field: int64 block_time_ms = 15;
   */
  blockTimeMs = protoInt64.zero

  constructor(data?: PartialMessage<PositionLiquidatedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.PositionLiquidatedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trader_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 3,
      name: "exchanged_quote_amount",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 4,
      name: "exchanged_position_size",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 5, name: "liquidator_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "fee_to_liquidator", kind: "message", T: Coin },
    { no: 7, name: "fee_to_ecosystem_fund", kind: "message", T: Coin },
    { no: 8, name: "bad_debt", kind: "message", T: Coin },
    { no: 9, name: "margin", kind: "message", T: Coin },
    { no: 10, name: "position_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "position_size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "unrealizedPnl", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 13, name: "mark_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 14, name: "block_height", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "block_time_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): PositionLiquidatedEvent {
    return new PositionLiquidatedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): PositionLiquidatedEvent {
    return new PositionLiquidatedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): PositionLiquidatedEvent {
    return new PositionLiquidatedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: PositionLiquidatedEvent | PlainMessage<PositionLiquidatedEvent> | undefined,
    b: PositionLiquidatedEvent | PlainMessage<PositionLiquidatedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(PositionLiquidatedEvent, a, b)
  }
}

/**
 * Emitted when a position is settled.
 *
 * @generated from message nibiru.perp.v2.PositionSettledEvent
 */
export class PositionSettledEvent extends Message<PositionSettledEvent> {
  /**
   * Identifier for the virtual pool of the position.
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * Owner of the position.
   *
   * @generated from field: string trader_address = 2;
   */
  traderAddress = ""

  /**
   * Settled coin as dictated by the settlement price of the perp.amm.
   *
   * @generated from field: repeated cosmos.base.v1beta1.Coin settled_coins = 3;
   */
  settledCoins: Coin[] = []

  constructor(data?: PartialMessage<PositionSettledEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.PositionSettledEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trader_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "settled_coins", kind: "message", T: Coin, repeated: true },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): PositionSettledEvent {
    return new PositionSettledEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): PositionSettledEvent {
    return new PositionSettledEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): PositionSettledEvent {
    return new PositionSettledEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: PositionSettledEvent | PlainMessage<PositionSettledEvent> | undefined,
    b: PositionSettledEvent | PlainMessage<PositionSettledEvent> | undefined,
  ): boolean {
    return proto3.util.equals(PositionSettledEvent, a, b)
  }
}

/**
 * Emitted when the funding rate changes for a market.
 *
 * @generated from message nibiru.perp.v2.FundingRateChangedEvent
 */
export class FundingRateChangedEvent extends Message<FundingRateChangedEvent> {
  /**
   * The pair for which the funding rate was calculated.
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * The mark price of the pair.
   *
   * @generated from field: string mark_price_twap = 2;
   */
  markPriceTwap = ""

  /**
   * The oracle index price of the pair.
   *
   * @generated from field: string index_price_twap = 3;
   */
  indexPriceTwap = ""

  /**
   * The latest premium fraction just calculated.
   *
   * @generated from field: string premium_fraction = 5;
   */
  premiumFraction = ""

  /**
   * The market's latest cumulative premium fraction.
   * The funding payment a position will pay is the difference between this
   * value and the latest cumulative premium fraction on the position,
   * multiplied by the position size.
   *
   * @generated from field: string cumulative_premium_fraction = 6;
   */
  cumulativePremiumFraction = ""

  constructor(data?: PartialMessage<FundingRateChangedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.FundingRateChangedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mark_price_twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "index_price_twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "premium_fraction", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 6,
      name: "cumulative_premium_fraction",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FundingRateChangedEvent {
    return new FundingRateChangedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FundingRateChangedEvent {
    return new FundingRateChangedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FundingRateChangedEvent {
    return new FundingRateChangedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: FundingRateChangedEvent | PlainMessage<FundingRateChangedEvent> | undefined,
    b: FundingRateChangedEvent | PlainMessage<FundingRateChangedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(FundingRateChangedEvent, a, b)
  }
}

/**
 * Emitted when liquidation fails.
 *
 * @generated from message nibiru.perp.v2.LiquidationFailedEvent
 */
export class LiquidationFailedEvent extends Message<LiquidationFailedEvent> {
  /**
   * The pair for which we are trying to liquidate.
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * owner of the position.
   *
   * @generated from field: string trader = 2;
   */
  trader = ""

  /**
   * Address of the account that executed the tx.
   *
   * @generated from field: string liquidator = 3;
   */
  liquidator = ""

  /**
   * Reason for the liquidation failure.
   *
   * @generated from field: nibiru.perp.v2.LiquidationFailedEvent.LiquidationFailedReason reason = 4;
   */
  reason = LiquidationFailedEvent_LiquidationFailedReason.UNSPECIFIED

  constructor(data?: PartialMessage<LiquidationFailedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.LiquidationFailedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "trader", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "liquidator", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 4,
      name: "reason",
      kind: "enum",
      T: proto3.getEnumType(LiquidationFailedEvent_LiquidationFailedReason),
    },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): LiquidationFailedEvent {
    return new LiquidationFailedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): LiquidationFailedEvent {
    return new LiquidationFailedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): LiquidationFailedEvent {
    return new LiquidationFailedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: LiquidationFailedEvent | PlainMessage<LiquidationFailedEvent> | undefined,
    b: LiquidationFailedEvent | PlainMessage<LiquidationFailedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(LiquidationFailedEvent, a, b)
  }
}

/**
 * @generated from enum nibiru.perp.v2.LiquidationFailedEvent.LiquidationFailedReason
 */
export enum LiquidationFailedEvent_LiquidationFailedReason {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the position is healthy and does not need to be liquidated.
   *
   * @generated from enum value: POSITION_HEALTHY = 1;
   */
  POSITION_HEALTHY = 1,

  /**
   * the pair does not exist.
   *
   * @generated from enum value: NONEXISTENT_PAIR = 2;
   */
  NONEXISTENT_PAIR = 2,

  /**
   * the position does not exist.
   *
   * @generated from enum value: NONEXISTENT_POSITION = 3;
   */
  NONEXISTENT_POSITION = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LiquidationFailedEvent_LiquidationFailedReason)
proto3.util.setEnumType(
  LiquidationFailedEvent_LiquidationFailedReason,
  "nibiru.perp.v2.LiquidationFailedEvent.LiquidationFailedReason",
  [
    { no: 0, name: "UNSPECIFIED" },
    { no: 1, name: "POSITION_HEALTHY" },
    { no: 2, name: "NONEXISTENT_PAIR" },
    { no: 3, name: "NONEXISTENT_POSITION" },
  ],
)

/**
 * This event is emitted when the amm is updated, which can be triggered by
 * the following events:
 *
 * - swap
 * - edit price multiplier
 * - edit depth
 *
 * @generated from message nibiru.perp.v2.AmmUpdatedEvent
 */
export class AmmUpdatedEvent extends Message<AmmUpdatedEvent> {
  /**
   * the final state of the AMM
   *
   * @generated from field: nibiru.perp.v2.AMM final_amm = 1;
   */
  finalAmm?: AMM

  /**
   * The mark price of the pair.
   *
   * @generated from field: string mark_price_twap = 2;
   */
  markPriceTwap = ""

  /**
   * The oracle index price of the pair.
   *
   * @generated from field: string index_price_twap = 3;
   */
  indexPriceTwap = ""

  constructor(data?: PartialMessage<AmmUpdatedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.AmmUpdatedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "final_amm", kind: "message", T: AMM },
    { no: 2, name: "mark_price_twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "index_price_twap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): AmmUpdatedEvent {
    return new AmmUpdatedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): AmmUpdatedEvent {
    return new AmmUpdatedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): AmmUpdatedEvent {
    return new AmmUpdatedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: AmmUpdatedEvent | PlainMessage<AmmUpdatedEvent> | undefined,
    b: AmmUpdatedEvent | PlainMessage<AmmUpdatedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(AmmUpdatedEvent, a, b)
  }
}

/**
 * This event is emitted at the end of every block for persisting market changes
 * off-chain
 *
 * Market changes are triggered by the following actions:
 *
 * - disabling market
 * - changing market fees
 * - bad debt is prepaid by the ecosystem fund
 *
 * @generated from message nibiru.perp.v2.MarketUpdatedEvent
 */
export class MarketUpdatedEvent extends Message<MarketUpdatedEvent> {
  /**
   * the final state of the market
   *
   * @generated from field: nibiru.perp.v2.Market final_market = 1;
   */
  finalMarket?: Market

  constructor(data?: PartialMessage<MarketUpdatedEvent>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.MarketUpdatedEvent"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "final_market", kind: "message", T: Market },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): MarketUpdatedEvent {
    return new MarketUpdatedEvent().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): MarketUpdatedEvent {
    return new MarketUpdatedEvent().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): MarketUpdatedEvent {
    return new MarketUpdatedEvent().fromJsonString(jsonString, options)
  }

  static equals(
    a: MarketUpdatedEvent | PlainMessage<MarketUpdatedEvent> | undefined,
    b: MarketUpdatedEvent | PlainMessage<MarketUpdatedEvent> | undefined,
  ): boolean {
    return proto3.util.equals(MarketUpdatedEvent, a, b)
  }
}
