// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file nibiru/perp/v2/state.proto (package nibiru.perp.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf"
import { Duration, Message, proto3, protoInt64 } from "@bufbuild/protobuf"
import { Coin } from "../../../cosmos/base/v1beta1/coin_pb.js"

/**
 * The direction that the user is trading in
 * LONG means the user is going long the base asset (e.g. buy BTC)
 * SHORT means the user is shorting the base asset (e.g. sell BTC)
 *
 * @generated from enum nibiru.perp.v2.Direction
 */
export enum Direction {
  /**
   * @generated from enum value: DIRECTION_UNSPECIFIED = 0;
   */
  DIRECTION_UNSPECIFIED = 0,

  /**
   * @generated from enum value: LONG = 1;
   */
  LONG = 1,

  /**
   * @generated from enum value: SHORT = 2;
   */
  SHORT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Direction)
proto3.util.setEnumType(Direction, "nibiru.perp.v2.Direction", [
  { no: 0, name: "DIRECTION_UNSPECIFIED" },
  { no: 1, name: "LONG" },
  { no: 2, name: "SHORT" },
])

/**
 * Enumerates different options of calculating twap.
 *
 * @generated from enum nibiru.perp.v2.TwapCalcOption
 */
export enum TwapCalcOption {
  /**
   * @generated from enum value: TWAP_CALC_OPTION_UNSPECIFIED = 0;
   */
  TWAP_CALC_OPTION_UNSPECIFIED = 0,

  /**
   * Spot price from quote asset reserve / base asset reserve
   *
   * @generated from enum value: SPOT = 1;
   */
  SPOT = 1,

  /**
   * Swapping with quote assets, output denominated in base assets
   *
   * @generated from enum value: QUOTE_ASSET_SWAP = 2;
   */
  QUOTE_ASSET_SWAP = 2,

  /**
   * Swapping with base assets, output denominated in quote assets
   *
   * @generated from enum value: BASE_ASSET_SWAP = 3;
   */
  BASE_ASSET_SWAP = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TwapCalcOption)
proto3.util.setEnumType(TwapCalcOption, "nibiru.perp.v2.TwapCalcOption", [
  { no: 0, name: "TWAP_CALC_OPTION_UNSPECIFIED" },
  { no: 1, name: "SPOT" },
  { no: 2, name: "QUOTE_ASSET_SWAP" },
  { no: 3, name: "BASE_ASSET_SWAP" },
])

/**
 * @generated from message nibiru.perp.v2.Market
 */
export class Market extends Message<Market> {
  /**
   * the trading pair represented by this market
   * always BASE:QUOTE, e.g. BTC:NUSD or ETH:NUSD
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * whether or not the market is enabled
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false

  /**
   * the minimum margin ratio which a user must maintain on this market
   *
   * @generated from field: string maintenance_margin_ratio = 3;
   */
  maintenanceMarginRatio = ""

  /**
   * the maximum leverage a user is able to be taken on this market
   *
   * @generated from field: string max_leverage = 4;
   */
  maxLeverage = ""

  /**
   * Latest cumulative premium fraction for a given pair.
   * Calculated once per funding rate interval.
   * A premium fraction is the difference between mark and index, divided by the
   * number of payments per day. (mark - index) / # payments in a day
   *
   * @generated from field: string latest_cumulative_premium_fraction = 5;
   */
  latestCumulativePremiumFraction = ""

  /**
   * the percentage of the notional given to the exchange when trading
   *
   * @generated from field: string exchange_fee_ratio = 6;
   */
  exchangeFeeRatio = ""

  /**
   * the percentage of the notional transferred to the ecosystem fund when
   * trading
   *
   * @generated from field: string ecosystem_fund_fee_ratio = 7;
   */
  ecosystemFundFeeRatio = ""

  /**
   * the percentage of liquidated position that will be
   * given to out as a reward. Half of the liquidation fee is given to the
   * liquidator, and the other half is given to the ecosystem fund.
   *
   * @generated from field: string liquidation_fee_ratio = 8;
   */
  liquidationFeeRatio = ""

  /**
   * the portion of the position size we try to liquidate if the available
   * margin is higher than liquidation fee
   *
   * @generated from field: string partial_liquidation_ratio = 9;
   */
  partialLiquidationRatio = ""

  /**
   * specifies the interval on which the funding rate is updated
   *
   * @generated from field: string funding_rate_epoch_id = 10;
   */
  fundingRateEpochId = ""

  /**
   * amount of time to look back for TWAP calculations
   *
   * @generated from field: google.protobuf.Duration twap_lookback_window = 11;
   */
  twapLookbackWindow?: Duration

  /**
   * the amount of collateral already credited from the ecosystem fund
   *
   * @generated from field: cosmos.base.v1beta1.Coin prepaid_bad_debt = 12;
   */
  prepaidBadDebt?: Coin

  constructor(data?: PartialMessage<Market>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.Market"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    {
      no: 3,
      name: "maintenance_margin_ratio",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 4, name: "max_leverage", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 5,
      name: "latest_cumulative_premium_fraction",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 6, name: "exchange_fee_ratio", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 7,
      name: "ecosystem_fund_fee_ratio",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 8,
      name: "liquidation_fee_ratio",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 9,
      name: "partial_liquidation_ratio",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 10,
      name: "funding_rate_epoch_id",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 11, name: "twap_lookback_window", kind: "message", T: Duration },
    { no: 12, name: "prepaid_bad_debt", kind: "message", T: Coin },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Market {
    return new Market().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Market {
    return new Market().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Market {
    return new Market().fromJsonString(jsonString, options)
  }

  static equals(
    a: Market | PlainMessage<Market> | undefined,
    b: Market | PlainMessage<Market> | undefined,
  ): boolean {
    return proto3.util.equals(Market, a, b)
  }
}

/**
 * @generated from message nibiru.perp.v2.AMM
 */
export class AMM extends Message<AMM> {
  /**
   * identifies the market this AMM belongs to
   *
   * @generated from field: string pair = 1;
   */
  pair = ""

  /**
   * the amount of base reserves this AMM has
   *
   * @generated from field: string base_reserve = 2;
   */
  baseReserve = ""

  /**
   * the amount of quote reserves this AMM has
   *
   * @generated from field: string quote_reserve = 3;
   */
  quoteReserve = ""

  /**
   * sqrt(k)
   *
   * @generated from field: string sqrt_depth = 4;
   */
  sqrtDepth = ""

  /**
   * the price multiplier of the dynamic AMM
   *
   * @generated from field: string price_multiplier = 5;
   */
  priceMultiplier = ""

  /**
   * Total long refers to the sum of long open notional in base.
   *
   * @generated from field: string total_long = 6;
   */
  totalLong = ""

  /**
   * Total short refers to the sum of short open notional in base.
   *
   * @generated from field: string total_short = 7;
   */
  totalShort = ""

  constructor(data?: PartialMessage<AMM>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.AMM"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "base_reserve", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "quote_reserve", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "sqrt_depth", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "price_multiplier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "total_long", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "total_short", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AMM {
    return new AMM().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AMM {
    return new AMM().fromJson(jsonValue, options)
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AMM {
    return new AMM().fromJsonString(jsonString, options)
  }

  static equals(
    a: AMM | PlainMessage<AMM> | undefined,
    b: AMM | PlainMessage<AMM> | undefined,
  ): boolean {
    return proto3.util.equals(AMM, a, b)
  }
}

/**
 * @generated from message nibiru.perp.v2.Position
 */
export class Position extends Message<Position> {
  /**
   * address identifies the address owner of this position
   *
   * @generated from field: string trader_address = 1;
   */
  traderAddress = ""

  /**
   * pair identifies the pair associated with this position
   *
   * @generated from field: string pair = 2;
   */
  pair = ""

  /**
   * the position size
   *
   * @generated from field: string size = 3;
   */
  size = ""

  /**
   * amount of margin remaining in the position
   *
   * @generated from field: string margin = 4;
   */
  margin = ""

  /**
   * value of position in quote assets when opened
   *
   * @generated from field: string open_notional = 5;
   */
  openNotional = ""

  /**
   * The most recent cumulative premium fraction this position has.
   * Used to calculate the next funding payment.
   *
   * @generated from field: string latest_cumulative_premium_fraction = 6;
   */
  latestCumulativePremiumFraction = ""

  /**
   * last block number this position was updated
   *
   * @generated from field: int64 last_updated_block_number = 7;
   */
  lastUpdatedBlockNumber = protoInt64.zero

  constructor(data?: PartialMessage<Position>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.Position"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trader_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pair", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "size", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "margin", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "open_notional", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 6,
      name: "latest_cumulative_premium_fraction",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 7,
      name: "last_updated_block_number",
      kind: "scalar",
      T: 3 /* ScalarType.INT64 */,
    },
  ])

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Position {
    return new Position().fromBinary(bytes, options)
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Position {
    return new Position().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Position {
    return new Position().fromJsonString(jsonString, options)
  }

  static equals(
    a: Position | PlainMessage<Position> | undefined,
    b: Position | PlainMessage<Position> | undefined,
  ): boolean {
    return proto3.util.equals(Position, a, b)
  }
}

/**
 * a snapshot of the perp.amm's reserves at a given point in time
 *
 * @generated from message nibiru.perp.v2.ReserveSnapshot
 */
export class ReserveSnapshot extends Message<ReserveSnapshot> {
  /**
   * @generated from field: nibiru.perp.v2.AMM amm = 1;
   */
  amm?: AMM

  /**
   * milliseconds since unix epoch
   *
   * @generated from field: int64 timestamp_ms = 2;
   */
  timestampMs = protoInt64.zero

  constructor(data?: PartialMessage<ReserveSnapshot>) {
    super()
    proto3.util.initPartial(data, this)
  }

  static readonly runtime: typeof proto3 = proto3
  static readonly typeName = "nibiru.perp.v2.ReserveSnapshot"
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "amm", kind: "message", T: AMM },
    { no: 2, name: "timestamp_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ])

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ReserveSnapshot {
    return new ReserveSnapshot().fromBinary(bytes, options)
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ReserveSnapshot {
    return new ReserveSnapshot().fromJson(jsonValue, options)
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ReserveSnapshot {
    return new ReserveSnapshot().fromJsonString(jsonString, options)
  }

  static equals(
    a: ReserveSnapshot | PlainMessage<ReserveSnapshot> | undefined,
    b: ReserveSnapshot | PlainMessage<ReserveSnapshot> | undefined,
  ): boolean {
    return proto3.util.equals(ReserveSnapshot, a, b)
  }
}
