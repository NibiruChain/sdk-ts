directive @goModel(
  model: String
  models: [String!]
) on ENUM | INPUT_OBJECT | INTERFACE | OBJECT | SCALAR | UNION

type Block {
  block: Int!
  block_duration: Float!
  block_ts: Int!
  num_txs: Int!
}

input CommunityPoolFilter {
  denom: String
}

enum CommunityPoolOrder {
  denom
}

type Delegation {
  amount: Int!
  delegator: User!
  validator: Validator!
}

input DelegationFilter {
  delegator_address: String
  validator_address: String
}

enum DelegationOrder {
  delegator_address
  validator_address
}

type DistributionCommission {
  commission: [Token!]
  validator: Validator!
}

input DistributionCommissionFilter {
  validator_address: String
}

enum DistributionCommissionOrder {
  validator_address
}

input FloatFilter {
  eq: Float
  gt: Float
  gte: Float
  lt: Float
  lte: Float
}

type GovDeposit {
  amount: [Token!]!
  block: Block!
  proposal: GovProposal!
  sender: User!
}

input GovDepositsFilter {
  block: IntFilter
  proposalId: IntFilter
  senderEq: String
}

enum GovDepositsOrder {
  block
  proposal_id
  sender
}

type GovProposal {
  depositEndTime: Time!
  finalTallyResultAbstain: Int!
  finalTallyResultNo: Int!
  finalTallyResultNoWithVeto: Int!
  finalTallyResultYes: Int!
  id: Int!
  metadata: String!
  proposer: User!
  status: String!
  submitTime: Time!
  summary: String!
  title: String!
  totalDeposit: [Token!]!
  votingEndTime: Time
  votingStartTime: Time
}

input GovProposalsFilter {
  depositEndTime: TimeFilter
  finalTallyResultAbstain: IntFilter
  finalTallyResultNo: IntFilter
  finalTallyResultNoWithVeto: IntFilter
  finalTallyResultYes: IntFilter
  id: IntFilter
  proposerEq: String
  submitTime: TimeFilter
  summary: StringFilter
  title: StringFilter
  votingEndTime: TimeFilter
  votingStartTime: TimeFilter
}

enum GovProposalsOrder {
  deposit_end_time
  final_tally_result_abstain
  final_tally_result_no
  final_tally_result_no_with_veto
  final_tally_result_yes
  id
  proposer
  status
  submit_time
  summary
  title
  voting_end_time
  voting_start_time
}

type GovVote {
  block: Block!
  option: String!
  proposal: GovProposal!
  sender: User!
}

input GovVotesFilter {
  block: IntFilter
  optionEq: String
  proposalId: IntFilter
  senderEq: String
}

enum GovVotesOrder {
  block
  option
  proposal_id
  sender
}

type Governance {
  govDeposits(
    limit: Int
    order: GovDepositsOrder
    orderDesc: Boolean
    where: GovDepositsFilter
  ): [GovDeposit!]!
  govProposals(
    limit: Int
    order: GovProposalsOrder
    orderDesc: Boolean
    where: GovProposalsFilter
  ): [GovProposal!]!
  govVotes(
    limit: Int
    order: GovVotesOrder
    orderDesc: Boolean
    where: GovVotesFilter
  ): [GovVote!]!
}

input IntFilter {
  eq: Int
  gt: Int
  gte: Int
  lt: Int
  lte: Int
}

type MarkPriceCandle {
  close: Float!
  high: Float!
  low: Float!
  open: Float!
  pair: String!
  period: Int!
  periodStartTs: Time!
  volume: Float!
  volumeNotional: Float!
}

input MarkPriceCandlesFilter {
  pairEq: String
  periodEq: Int
  periodGt: Int
  periodGte: Int
  periodLt: Int
  periodLte: Int
  periodStartTsEq: Time
  periodStartTsGt: Time
  periodStartTsGte: Time
  periodStartTsLt: Time
  periodStartTsLte: Time
}

enum MarkPriceCandlesOrder {
  period
  period_start_ts
}

type Oracle {
  oraclePrices(
    limit: Int
    offset: Int
    order_by: OraclePricesOrder
    order_desc: Boolean
    where: OraclePricesFilter
  ): [OraclePrice!]!
  oracles(
    limit: Int
    order_by: OraclesOrder
    order_desc: Boolean
    where: OraclesFilter
  ): [OracleEntry!]!
}

type OracleEntry {
  numVotes: Int!
  validator: Validator!
}

type OraclePrice {
  block: Block!
  eventSeqNo: Int!
  pair: String!
  price: Float!
  txSeqNo: Int!
}

input OraclePricesFilter {
  block: IntFilter
  blockTs: TimeFilter
  pair: StringFilter
}

enum OraclePricesOrder {
  pair
  price
  sequence
}

input OraclesFilter {
  numVotes: IntFilter
  validatorAddressEq: String
}

enum OraclesOrder {
  num_votes
  validator_address
}

input PeriodFilter {
  periodEq: Int
  periodGt: Int
  periodGte: Int
  periodLt: Int
  periodLte: Int
  periodStartTsEq: Time
  periodStartTsGt: Time
  periodStartTsGte: Time
  periodStartTsLt: Time
  periodStartTsLte: Time
}

type Perp {
  leaderboard(
    limit: Int
    order_by: PerpLeaderboardOrder
    order_desc: Boolean
    where: PerpLeaderboardFilter
  ): [PerpLeaderboard!]!
  market(where: PerpMarketFilter!): PerpMarket
  markets(
    limit: Int
    order_by: PerpMarketOrder
    order_desc: Boolean
    where: PerpMarketsFilter
  ): [PerpMarket!]!
  position(where: PerpPositionFilter!): PerpPosition
  positionChanges(
    limit: Int
    offset: Int
    order_by: PerpPositionChangeOrder
    order_desc: Boolean
    where: PerpPositionChangeFilter!
  ): [PerpPositionChange!]!
  positions(
    limit: Int
    order_by: PerpPositionOrder
    order_desc: Boolean
    where: PerpPositionsFilter
  ): [PerpPosition!]!
}

type PerpLeaderboard {
  avg_pct_pnl: Float!
  avg_pct_pnl_rank: Int!
  input_margin: Float!
  raw_pnl: Float!
  raw_pnl_with_unrealized: Float!
  trader_address: String!
}

input PerpLeaderboardFilter {
  trader_address: String
}

enum PerpLeaderboardOrder {
  avg_pct_pnl
  avg_pct_pnl_rank
  raw_pnl
  raw_pnl_with_unrealized
  trader_address
}

type PerpMarket {
  base_reserve: Float!
  ecosystem_fund_fee_ratio: Float!
  enabled: Boolean!
  exchange_fee_ratio: Float!
  funding_rate_epoch_id: String!
  index_price_twap: Float!
  is_deleted: Boolean!
  latest_cumulative_premium_fraction: Float!
  liquidation_fee_ratio: Float!
  maintenance_margin_ratio: Float!
  mark_price: Float!
  mark_price_twap: Float!
  max_funding_rate: Float
  max_leverage: Float!
  pair: String!
  partial_liquidation_ratio: Float!
  prepaid_bad_debt: Token!
  price_multiplier: Float!
  quote_reserve: Float!
  sqrt_depth: Float!
  total_long: Float!
  total_short: Float!
  twap_lookback_window: String!
}

input PerpMarketFilter {
  pair: String!
}

enum PerpMarketOrder {
  pair
}

input PerpMarketsFilter {
  is_deleted: Boolean
  pair: String
}

type PerpPosition {
  bad_debt: Float!
  last_updated_block: Block!
  latest_cumulative_premium_fraction: Float!
  liquidation_price: Float!
  margin: Float!
  margin_ratio: Float!
  open_notional: Float!
  pair: String!
  position_notional: Float!
  size: Float!
  trader_address: String!
  unrealized_funding_payment: Float!
  unrealized_pnl: Float!
}

type PerpPositionChange {
  badDebt: Token
  block: Block!
  changeReason: String!
  eventSeqNo: Int!
  exchangedNotional: Float!
  exchangedSize: Float!
  fundingPayment: Float
  latestCumulativePremiumFraction: Float
  margin: Float!
  marginToUser: Int
  openNotional: Float!
  pair: String!
  positionNotional: Float!
  realizedPnl: Float
  size: Float!
  traderAddress: String!
  transactionFee: Token
  txSeqNo: Int!
}

input PerpPositionChangeFilter {
  block: IntFilter
  blockTs: TimeFilter
  pair: StringFilter
  traderAddressEq: String!
}

enum PerpPositionChangeOrder {
  exchanged_notional
  exchanged_size
  margin
  open_notional
  pair
  position_notional
  sequence
  size
}

input PerpPositionFilter {
  pair: String!
  trader_address: String!
}

enum PerpPositionOrder {
  created_block
  pair
  trader_address
}

input PerpPositionsFilter {
  include_closed: Boolean
  pair: String
  trader_address: String
}

type Query {
  communityPool(
    limit: Int
    order_by: CommunityPoolOrder
    order_desc: Boolean
    where: CommunityPoolFilter
  ): [Token!]!
  delegations(
    limit: Int
    order_by: DelegationOrder
    order_desc: Boolean
    where: DelegationFilter
  ): [Delegation!]!
  distributionCommissions(
    limit: Int
    order_by: DistributionCommissionOrder
    order_desc: Boolean
    where: DistributionCommissionFilter
  ): [DistributionCommission!]!
  governance: Governance!
  markPriceCandles(
    limit: Int
    order_by: MarkPriceCandlesOrder
    order_desc: Boolean
    where: MarkPriceCandlesFilter
  ): [MarkPriceCandle!]!
  oracle: Oracle!
  perp: Perp!
  perpLeaderboard(
    limit: Int
    order_by: PerpLeaderboardOrder
    order_desc: Boolean
    where: PerpLeaderboardFilter
  ): [PerpLeaderboard!]! @deprecated(reason: "Moved to perp sub schema")
  perpMarket(where: PerpMarketFilter!): PerpMarket
    @deprecated(reason: "Moved to perp sub schema")
  perpMarkets(
    limit: Int
    order_by: PerpMarketOrder
    order_desc: Boolean
    where: PerpMarketsFilter
  ): [PerpMarket!]! @deprecated(reason: "Moved to perp sub schema")
  perpPosition(where: PerpPositionFilter!): PerpPosition
    @deprecated(reason: "Moved to perp sub schema")
  perpPositions(
    limit: Int
    order_by: PerpPositionOrder
    order_desc: Boolean
    where: PerpPositionsFilter
  ): [PerpPosition!]! @deprecated(reason: "Moved to perp sub schema")
  redelegations(
    limit: Int
    order_by: RedelegationOrder
    order_desc: Boolean
    where: RedelegationFilter
  ): [Redelegation!]!
  spotLpPositions(
    limit: Int
    order_by: SpotLpPositionOrder
    order_desc: Boolean
    where: SpotLpPositionFilter
  ): [SpotLpPosition!]!
  spotPoolCreated(
    limit: Int
    order_by: SpotPoolCreatedOrder
    order_desc: Boolean
    where: SpotPoolCreatedFilter
  ): [SpotPoolCreated!]!
  spotPoolExited(
    limit: Int
    order_by: SpotPoolExitedOrder
    order_desc: Boolean
    where: SpotPoolExitedFilter
  ): [SpotPoolExited!]!
  spotPoolJoined(
    limit: Int
    order_by: SpotPoolJoinedOrder
    order_desc: Boolean
    where: SpotPoolJoinedFilter
  ): [SpotPoolJoined!]!
  spotPoolSwap(
    limit: Int
    order_by: SpotPoolSwapOrder
    order_desc: Boolean
    where: SpotPoolSwapFilter
  ): [SpotPoolSwap!]!
  spotPools(
    limit: Int
    order_by: SpotPoolOrder
    order_desc: Boolean
    where: SpotPoolFilter
  ): [SpotPool!]!
  stats: Stats!
  unbondings(
    limit: Int
    order_by: UnbondingOrder
    order_desc: Boolean
    where: UnbondingFilter
  ): [Unbonding!]!
  users(
    limit: Int
    order_by: UserOrder
    order_desc: Boolean
    where: UserFilter
  ): [User!]!
  validators(
    limit: Int
    order_by: ValidatorOrder
    order_desc: Boolean
    where: ValidatorFilter
  ): [Validator!]!
}

type Redelegation {
  amount: Int!
  completion_time: String!
  creation_block: Block!
  delegator: User!
  destination_validator: Validator!
  source_validator: Validator!
}

input RedelegationFilter {
  delegator_address: String
  destination_validator_address: String
  source_validator_address: String
}

enum RedelegationOrder {
  completion_time
  creation_height
  delegator_address
  destinaiton_validator_address
  source_validator_address
}

type SpotLpPosition {
  created_block: Block!
  pool: SpotPool!
  pool_shares: Token!
  user: User!
}

input SpotLpPositionFilter {
  pool_id: Int
  user_address: String
}

enum SpotLpPositionOrder {
  pool_id
  user_address
}

type SpotPool {
  amplification: Float!
  created_block: Block!
  exit_fee: Float!
  pool_id: Int!
  pool_type: String!
  swap_fee: Float!
  tokens: [Token!]!
  total_shares: Token!
  total_weight: Float!
  weights: [Token!]!
}

type SpotPoolCreated {
  block: Block!
  pool: SpotPool!
  pool_shares: Token!
  user: User!
}

input SpotPoolCreatedFilter {
  pool_id: Int
  user_address: String
}

enum SpotPoolCreatedOrder {
  pool_id
  user_address
}

type SpotPoolExited {
  block: Block!
  pool: SpotPool!
  pool_shares: Token!
  user: User!
}

input SpotPoolExitedFilter {
  pool_id: Int
  user_address: String
}

enum SpotPoolExitedOrder {
  pool_id
  user_address
}

input SpotPoolFilter {
  pool_id: Int
}

type SpotPoolJoined {
  block: Block!
  pool: SpotPool!
  pool_shares: Token!
  user: User!
}

input SpotPoolJoinedFilter {
  pool_id: Int
  user_address: String
}

enum SpotPoolJoinedOrder {
  pool_id
  user_address
}

enum SpotPoolOrder {
  pool_id
}

type SpotPoolSwap {
  block: Block!
  pool: SpotPool!
  token_in: Token!
  token_out: Token!
  user: User!
}

input SpotPoolSwapFilter {
  block_eq: Int
  block_gte: Int
  block_lte: Int
  pool_id: Int
  user_address: String
}

enum SpotPoolSwapOrder {
  block
  pool_id
  user_address
}

type Stats {
  fees(
    limit: Int
    order: StatsFeesOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsFees!]!
  perpOpenInterest(
    limit: Int
    order: StatsPerpOpenInterestOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsPerpOpenInterest!]!
  perpPnl(
    limit: Int
    order: StatsPerpPnlOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsPerpPnl!]!
  totals(
    limit: Int
    order: StatsTotalsOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsTotals!]!
  tvl(
    limit: Int
    order: StatsTvlOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsTvl!]!
  users(
    limit: Int
    order: StatsUsersOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsUsers!]!
  volume(
    limit: Int
    order: StatsVolumeOrder
    orderDesc: Boolean
    where: PeriodFilter
  ): [StatsVolume!]!
}

type StatsFees {
  feesLiquidations: Float!
  feesLiquidationsCumulative: Float!
  feesPerp: Float!
  feesPerpCumulative: Float!
  feesSwap: Float!
  feesSwapCumulative: Float!
  feesTotal: Float!
  feesTotalCumulative: Float!
  period: Int!
  periodStartTs: Time!
}

enum StatsFeesOrder {
  fees_liquidations
  fees_liquidations_cumulative
  fees_perp
  fees_perp_cumulative
  fees_swap
  fees_swap_cumulative
  fees_total
  fees_total_cumulative
  period
  period_start_ts
}

type StatsPerpOpenInterest {
  openInterestLong: Float!
  openInterestShort: Float!
  openInterestTotal: Float!
  period: Int!
  periodStartTs: Time!
}

enum StatsPerpOpenInterestOrder {
  open_interest_long
  open_interest_short
  open_interest_total
  period
  period_start_ts
}

type StatsPerpPnl {
  loss: Float!
  lossCumulative: Float!
  netPnl: Float!
  netPnlCumulative: Float!
  period: Int!
  periodStartTs: Time!
  profit: Float!
  profitCumulative: Float!
}

enum StatsPerpPnlOrder {
  loss
  loss_cumulative
  net_pnl
  net_pnl_cumulative
  period
  period_start_ts
  profit
  profit_cumulative
}

type StatsTotals {
  period: Int!
  periodStartTs: Time!
  totalFeesLiquidations: Float!
  totalFeesPerp: Float!
  totalOpenInterest: Float!
  totalPerp: Float!
  totalSwap: Float!
  totalTvl: Float!
}

enum StatsTotalsOrder {
  period
  period_start_ts
  total_fees_liquidations
  total_fees_perp
  total_open_interest
  total_perp
  total_swap
  total_tvl
}

type StatsTvl {
  period: Int!
  periodStartTs: Time!
  tvlPerp: Float!
  tvlStablecoin: Float!
  tvlStaking: Float!
  tvlSwap: Float!
  tvlTotal: Float!
}

enum StatsTvlOrder {
  period
  period_start_ts
  tvl_perp
  tvl_stablecoin
  tvl_staking
  tvl_swap
  tvl_total
}

type StatsUsers {
  newUsersLp: Int!
  newUsersLpCumulative: Int!
  newUsersPerp: Int!
  newUsersPerpCumulative: Int!
  newUsersSwap: Int!
  newUsersSwapCumulative: Int!
  newUsersTotal: Int!
  newUsersTotalCumulative: Int!
  period: Int!
  periodStartTs: Time!
  uniqueUsersLp: Int!
  uniqueUsersPerp: Int!
  uniqueUsersSwap: Int!
  uniqueUsersTotal: Int!
  userActionsLp: Int!
  userActionsPerp: Int!
  userActionsSwap: Int!
  userActionsTotal: Int!
}

enum StatsUsersOrder {
  new_users_lp
  new_users_lp_cumulative
  new_users_perp
  new_users_perp_cumulative
  new_users_swap
  new_users_swap_cumulative
  new_users_total
  new_users_total_cumulative
  period
  period_start_ts
  unique_users_lp
  unique_users_perp
  unique_users_swap
  unique_users_total
  user_actions_lp
  user_actions_perp
  user_actions_swap
  user_actions_total
}

type StatsVolume {
  period: Int!
  periodStartTs: Time!
  volumePerp: Float!
  volumePerpCumulative: Float!
  volumeSwap: Float!
  volumeSwapCumulative: Float!
  volumeTotal: Float!
  volumeTotalCumulative: Float!
}

enum StatsVolumeOrder {
  period
  period_start_ts
  volume_perp
  volume_perp_cumulative
  volume_swap
  volume_swap_cumulative
  volume_total
  volume_total_cumulative
}

input StringFilter {
  eq: String
  like: String
}

input SubOraclePricesFilter {
  pair: String!
}

input SubPerpMarketFilter {
  pair: String!
}

input SubPerpPositionFilter {
  pair: String
  trader_address: String!
}

type Subscription {
  markPriceCandles(
    limit: Int
    where: MarkPriceCandlesFilter
  ): [MarkPriceCandle!]!
  oraclePrices(where: SubOraclePricesFilter): [OraclePrice!]!
  perpMarket(where: SubPerpMarketFilter!): PerpMarket!
  perpPositions(where: SubPerpPositionFilter!): [PerpPosition!]!
}

scalar Time

input TimeFilter {
  eq: Time
  gt: Time
  gte: Time
  lt: Time
  lte: Time
}

type Token {
  amount: String!
  denom: String!
}

type Unbonding {
  amount: Int!
  completion_time: String!
  creation_block: Block!
  delegator: User!
  validator: Validator!
}

input UnbondingFilter {
  delegator_address: String
  validator_address: String
}

enum UnbondingOrder {
  completion_time
  creation_height
  delegator_address
  validator_address
}

type User {
  address: String!
  balances: [Token]!
  created_block: Block!
}

input UserFilter {
  address: String
  created_block_eq: Int
  created_block_gte: Int
  created_block_lte: Int
}

enum UserOrder {
  address
  created_block
}

type Validator {
  commission_rates: ValidatorCommission
  commission_update_time: String!
  delegator_shares: Float!
  description: ValidatorDescription!
  jailed: Boolean!
  min_self_delegation: Int!
  operator_address: String!
  status: ValidatorStatus!
  tokens: Int!
  unbonding_block: Block!
  unbonding_time: String!
}

type ValidatorCommission {
  max_change_rate: Float!
  max_rate: Float!
  rate: Float!
}

type ValidatorDescription {
  details: String!
  identity: String!
  moniker: String!
  security_contact: String!
  website: String!
}

input ValidatorFilter {
  jailed: Boolean
  moniker: String
  operator_address: String
  status: ValidatorStatus
}

enum ValidatorOrder {
  jailed
  moniker
  operator_address
  status
  tokens
}

enum ValidatorStatus {
  BONDED
  UNBONDED
  UNBONDING
}
